{"ast":null,"code":"const fetch = require('@aero/centra'),\n      curSettings = {\n  baseUrl: 'https://disease.sh'\n},\n      fetchJson = path => fetch(`${curSettings.baseUrl}/${path}`).json(),\n      yesterday = {},\n      jhucsse = {},\n      historical = {},\n      nyt = {},\n      apple = {};\n\nconst createPath = (opts, path) => {\n  if (opts.sort || String(opts.strict) !== 'undefined' || opts.yesterday || String(opts.allowNull) !== 'undefined') {\n    path += '?';\n    if (opts.sort) path += `sort=${opts.sort}`;\n    if (opts.yesterday) path += (opts.sort ? '&' : '') + 'yesterday=' + opts.yesterday;\n    if (String(opts.allowNull) !== 'undefined') path += (opts.sort || opts.yesterday ? '&' : '') + 'allowNull=' + opts.yesterday;\n    if (String(opts.strict) !== 'undefined') path += (opts.sort || opts.yesterday || String(opts.allowNull) !== 'undefined' ? '&' : '') + 'strict=' + opts.strict;\n  }\n\n  return path;\n};\n\nconst _all = opts => fetchJson(createPath(opts, `v2/all`));\n/**\n * Specify settings to the wrapper\n * @param {object} opts         object holding the options\n * @param {string} opts.baseUrl url to use for requests\n */\n\n\nconst settings = (opts = {}) => ['https://disease.sh', 'https://api.caw.sh', 'https://corona.lmao.ninja'].includes(opts.baseUrl) && (curSettings.baseUrl = opts.baseUrl);\n/**\n * Retrieve a summary of global data\n * @param {object} opts             object holding the options for that request\n * @param {boolean} opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @returns {object}                summary object\n */\n\n\nconst all = (opts = {}) => _all(false, opts);\n/**\n * Retrieve country specific data\n * @param {object}               opts            object holding the options for that request\n * @param {string|string[]}      opts.country    country name/s to be queried      \n * @param {boolean}              opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @param {string}               opts.sort       property name which will be used for sorting     \n * @param {boolean}              opts.strict     whether to use strict name checking or not\n * @returns {object|object[]}                    country specific data\n */\n\n\nconst countries = (opts = {}) => {\n  let path = 'v2/countries';\n  if (opts.country) path += `/${Array.isArray(opts.country) ? opts.country.join('|') : opts.country}`;\n  return fetchJson(createPath(opts, path));\n};\n/**\n * Retrieve continent specific data\n * @param {object}               opts            object holding the options for that request\n * @param {string|string[]}      opts.continent  continent name/s to be queried      \n * @param {boolean}              opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @param {string}               opts.sort       property name which will be used for sorting     \n * @param {boolean}              opts.strict     whether to use strict name checking or not\n * @returns {object|object[]}                    continent specific data\n */\n\n\nconst continents = (opts = {}) => {\n  let path = 'v2/continents';\n  if (opts.continent) path += `/${opts.continent}`;\n  return fetchJson(createPath(opts, path));\n};\n/**\n * Retrieve state specific data\n * @param {object}               opts            object holding the options for that request\n * @param {string|string[]}      opts.state      state name/s to be queried      \n * @param {boolean}              opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @param {string}               opts.sort       property name which will be used for sorting     \n * @param {boolean}              opts.strict     whether to use strict name checking or not\n * @returns {object|object[]}                    state specific data\n */\n\n\nconst states = (opts = {}) => {\n  let path = 'v2/states';\n  if (opts.state) path += `/${Array.isArray(opts.state) ? opts.state.join('|') : opts.state}`;\n  return fetchJson(createPath(opts, path));\n};\n/**\n * Retrieve a summary of yesterdays global data\n * @param {object} opts             object holding the options for that request\n * @param {boolean} opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @returns {object}                summary object\n */\n\n\nyesterday.all = (opts = {}) => _all({ ...opts,\n  yesterday: true\n});\n/**\n * Retrieve yesterdays country specific data\n * @param {object}               opts            object holding the options for that request\n * @param {string|string[]}      opts.country    country name/s to be queried      \n * @param {boolean}              opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @param {string}               opts.sort       property name which will be used for sorting     \n * @param {boolean}              opts.strict     whether to use strict name checking or not\n * @returns {object|object[]}                    country specific data\n */\n\n\nyesterday.countries = (opts = {}) => countries({ ...opts,\n  yesterday: true\n});\n/**\n * Retrieve yesterdays continent specific data\n * @param {object}               opts           object holding the options for that request\n * @param {string|string[]}      opts.continent continent name/s to be queried      \n * @param {string}               opts.sort      property name which will be used for sorting     \n * @param {boolean}              opts.strict    whether to use strict name checking or not\n * @returns {object|object[]}              continent specific data\n */\n\n\nyesterday.continents = (opts = {}) => continents({ ...opts,\n  yesterday: true\n});\n/**\n * Retrieve yesterdays state specific data\n * @param {object}               opts            object holding the options for that request\n * @param {string|string[]}      opts.state      state name/s to be queried      \n * @param {boolean}              opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @param {string}               opts.sort       property name which will be used for sorting     \n * @param {boolean}              opts.strict     whether to use strict name checking or not\n * @returns {object|object[]}                    state specific data\n */\n\n\nyesterday.states = (opts = {}) => states({ ...opts,\n  yesterday: true\n});\n/**\n * Retrieve an array of infected countries\n * @returns {object[]} array of infected countries\n */\n\n\njhucsse.all = () => fetchJson('v2/jhucsse');\n/**\n * Retrieve county specific data\n * @param {object}           opts        object holding the options for that request\n * @param {string|string[]}  opts.county county name/s to be queried      \n * @returns {object|object[]}            county specific data\n */\n\n\njhucsse.counties = (opts = {}) => {\n  let path = 'v2/jhucsse/counties';\n  if (opts.county) path += `/${Array.isArray(opts.county) ? opts.county.join('|') : opts.county}`;\n  return fetchJson(path);\n};\n/**\n * Retrieve an array of the global timeline\n * @param {object}        opts        object holding the options for that request\n * @param {string|number} opts.days   the number of days to get data for, or 'all'\n * @returns {object[]}           timeline data\n */\n\n\nhistorical.all = (opts = {}) => fetchJson(`v2/historical/all${opts.days ? `?lastdays=${opts.days}` : ''}`);\n/**\n * Retrieve an array of the country specific timelines\n * @param {object}               opts           object holding the options for that request\n * @param {string|string[]} opts.country   country name/s to be queried\n * @param {string|string[]} opts.province  province name/s to be queried (must have 1 country)\n * @param {string|number}        opts.days      the number of days to get data for, or 'all'\n * @returns {object[]}                     timeline data\n */\n\n\nhistorical.countries = (opts = {}) => {\n  let path = 'v2/historical';\n\n  if (opts.country) {\n    path += `/${Array.isArray(opts.country) ? opts.country.join('|') : opts.country}`;\n    if (opts.province) path += `/${Array.isArray(opts.province) ? opts.province.join('|') : opts.province}`;\n    if (opts.days) path += `?lastdays=${opts.days}`;\n  }\n\n  return fetchJson(path);\n};\n/**\n * Retrieve a timeline of USA data\n * @returns {object[]} USA timeline data\n */\n\n\nnyt.usa = () => fetchJson('v2/nyt/usa');\n/**\n * Retrieve a timeline of US state specific data\n * @param {object} opts            object holding the options for that request\n * @param {string} opts.state      state name to be queried \n * @returns {object|object[]} state specific timeline data\n */\n\n\nnyt.states = (opts = {}) => {\n  let path = 'v2/nyt/states';\n  if (opts.state) path += `/${opts.state}`;\n  return fetchJson(path);\n};\n/**\n * Retrieve a timeline of US county specific data\n * @param {object} opts            object holding the options for that request\n * @param {string} opts.county     county name to be queried \n * @returns {object|object[]} county specific timeline data\n */\n\n\nnyt.counties = (opts = {}) => {\n  let path = 'v2/nyt/counties';\n  if (opts.county) path += `/${opts.county}`;\n  return fetchJson(path);\n};\n/**\n * Retrieve an array of available countries\n * @returns {string[]} country names\n */\n\n\napple.countries = () => fetchJson('v2/apple/countries');\n/**\n * Retrieve a list of available subregions for a country\n * @param {string} country country name to be queried\n * @returns {object}       object containing country name and list of subregions\n */\n\n\napple.subregions = country => fetchJson(`v2/apple/countries/${country}`);\n/**\n * Retrieve mobility data for a specific country and subregion\n * @param {object}               opts           object holding the options for that request\n * @param {string}               opts.country   country name to be queried      \n * @param {string|string[]} opts.subregion subregion name/s to be queried      \n * @returns {object|object[]}              mobility data\n */\n\n\napple.mobilityData = (opts = {}) => {\n  let path = 'v2/apple/countries';\n\n  if (opts.country) {\n    path += `/${opts.country}`;\n    if (opts.subregion) path += `/${Array.isArray(opts.subregion) ? opts.subregion.join('|') : opts.subregion}`;\n  }\n\n  return fetchJson(path);\n};\n/**\n * Retrieve official government data\n * @param {string}  country         country name to be queried (empty to get an array of names)\n * @param {boolean} opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @returns {object}                official government data\n */\n\n\nconst gov = country => fetchJson(`v2/gov/${country ? country : ''}`);\n\nmodule.exports = {\n  settings,\n  all,\n  countries,\n  continents,\n  states,\n  yesterday,\n  jhucsse,\n  historical,\n  nyt,\n  apple,\n  gov\n};","map":{"version":3,"sources":["/Users/utilizador/Documents/academia/LocalRepo/covid-react-app/node_modules/novelcovid/index.js"],"names":["fetch","require","curSettings","baseUrl","fetchJson","path","json","yesterday","jhucsse","historical","nyt","apple","createPath","opts","sort","String","strict","allowNull","_all","settings","includes","all","countries","country","Array","isArray","join","continents","continent","states","state","counties","county","days","province","usa","subregions","mobilityData","subregion","gov","module","exports"],"mappings":"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","sourcesContent":["const fetch = require('@aero/centra'),\n      curSettings = { baseUrl: 'https://disease.sh' },\n      fetchJson = (path) => fetch(`${curSettings.baseUrl}/${path}`).json(),\n      yesterday = {},\n      jhucsse = {},\n      historical = {},\n      nyt = {},\n      apple = {}\n\nconst createPath = (opts, path) => {\n  if(opts.sort || String(opts.strict) !== 'undefined' || opts.yesterday || String(opts.allowNull) !== 'undefined') {\n    path += '?'\n    if(opts.sort) \n      path += `sort=${opts.sort}`\n    if(opts.yesterday)\n      path += (opts.sort ?'&':'')+'yesterday='+opts.yesterday\n    if(String(opts.allowNull) !== 'undefined')\n      path += (opts.sort || opts.yesterday ?'&':'')+'allowNull='+opts.yesterday\n    if(String(opts.strict) !== 'undefined') \n      path += (opts.sort || opts.yesterday || String(opts.allowNull) !== 'undefined' ?'&':'')+'strict='+opts.strict\n  }\n  return path\n}\nconst _all = (opts) => fetchJson(createPath(opts, `v2/all`))\n\n/**\n * Specify settings to the wrapper\n * @param {object} opts         object holding the options\n * @param {string} opts.baseUrl url to use for requests\n */\nconst settings = (opts = {}) => ['https://disease.sh', 'https://api.caw.sh', 'https://corona.lmao.ninja'].includes(opts.baseUrl) && (curSettings.baseUrl = opts.baseUrl)\n\n/**\n * Retrieve a summary of global data\n * @param {object} opts             object holding the options for that request\n * @param {boolean} opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @returns {object}                summary object\n */\nconst all = (opts = {}) => _all(false, opts)\n\n/**\n * Retrieve country specific data\n * @param {object}               opts            object holding the options for that request\n * @param {string|string[]}      opts.country    country name/s to be queried      \n * @param {boolean}              opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @param {string}               opts.sort       property name which will be used for sorting     \n * @param {boolean}              opts.strict     whether to use strict name checking or not\n * @returns {object|object[]}                    country specific data\n */\nconst countries = (opts = {}) => {\n  let path = 'v2/countries'\n  if(opts.country) \n    path += `/${Array.isArray(opts.country) ? (opts.country.join('|')) : opts.country}`\n  return fetchJson(createPath(opts, path))\n}\n\n/**\n * Retrieve continent specific data\n * @param {object}               opts            object holding the options for that request\n * @param {string|string[]}      opts.continent  continent name/s to be queried      \n * @param {boolean}              opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @param {string}               opts.sort       property name which will be used for sorting     \n * @param {boolean}              opts.strict     whether to use strict name checking or not\n * @returns {object|object[]}                    continent specific data\n */\nconst continents = (opts = {}) => {\n  let path = 'v2/continents'\n  if(opts.continent) \n    path += `/${opts.continent}`\n  return fetchJson(createPath(opts, path))\n}\n\n/**\n * Retrieve state specific data\n * @param {object}               opts            object holding the options for that request\n * @param {string|string[]}      opts.state      state name/s to be queried      \n * @param {boolean}              opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @param {string}               opts.sort       property name which will be used for sorting     \n * @param {boolean}              opts.strict     whether to use strict name checking or not\n * @returns {object|object[]}                    state specific data\n */\nconst states = (opts = {}) => {\n  let path = 'v2/states'\n  if(opts.state) \n    path += `/${Array.isArray(opts.state) ? (opts.state.join('|')) : opts.state}`\n  return fetchJson(createPath(opts, path))\n}\n\n/**\n * Retrieve a summary of yesterdays global data\n * @param {object} opts             object holding the options for that request\n * @param {boolean} opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @returns {object}                summary object\n */\nyesterday.all = (opts = {}) => _all({...opts, yesterday: true})\n\n/**\n * Retrieve yesterdays country specific data\n * @param {object}               opts            object holding the options for that request\n * @param {string|string[]}      opts.country    country name/s to be queried      \n * @param {boolean}              opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @param {string}               opts.sort       property name which will be used for sorting     \n * @param {boolean}              opts.strict     whether to use strict name checking or not\n * @returns {object|object[]}                    country specific data\n */\nyesterday.countries = (opts = {}) => countries({...opts, yesterday: true})\n\n/**\n * Retrieve yesterdays continent specific data\n * @param {object}               opts           object holding the options for that request\n * @param {string|string[]}      opts.continent continent name/s to be queried      \n * @param {string}               opts.sort      property name which will be used for sorting     \n * @param {boolean}              opts.strict    whether to use strict name checking or not\n * @returns {object|object[]}              continent specific data\n */\nyesterday.continents = (opts = {}) => continents({...opts, yesterday: true})\n\n/**\n * Retrieve yesterdays state specific data\n * @param {object}               opts            object holding the options for that request\n * @param {string|string[]}      opts.state      state name/s to be queried      \n * @param {boolean}              opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @param {string}               opts.sort       property name which will be used for sorting     \n * @param {boolean}              opts.strict     whether to use strict name checking or not\n * @returns {object|object[]}                    state specific data\n */\nyesterday.states = (opts = {}) => states({...opts, yesterday: true})\n\n/**\n * Retrieve an array of infected countries\n * @returns {object[]} array of infected countries\n */\njhucsse.all = () => fetchJson('v2/jhucsse')\n\n/**\n * Retrieve county specific data\n * @param {object}           opts        object holding the options for that request\n * @param {string|string[]}  opts.county county name/s to be queried      \n * @returns {object|object[]}            county specific data\n */\njhucsse.counties = (opts =Â {}) => {\n  let path = 'v2/jhucsse/counties'\n  if(opts.county) \n    path += `/${Array.isArray(opts.county) ? (opts.county.join('|')) : opts.county}`\n  return fetchJson(path)\n}\n\n/**\n * Retrieve an array of the global timeline\n * @param {object}        opts        object holding the options for that request\n * @param {string|number} opts.days   the number of days to get data for, or 'all'\n * @returns {object[]}           timeline data\n */\nhistorical.all = (opts = {}) => fetchJson(`v2/historical/all${opts.days ? `?lastdays=${opts.days}`:''}`)\n\n/**\n * Retrieve an array of the country specific timelines\n * @param {object}               opts           object holding the options for that request\n * @param {string|string[]} opts.country   country name/s to be queried\n * @param {string|string[]} opts.province  province name/s to be queried (must have 1 country)\n * @param {string|number}        opts.days      the number of days to get data for, or 'all'\n * @returns {object[]}                     timeline data\n */\nhistorical.countries = (opts = {}) => {\n  let path = 'v2/historical'\n  if(opts.country) {\n    path += `/${Array.isArray(opts.country) ? (opts.country.join('|')) : opts.country}`\n    if(opts.province) \n      path += `/${Array.isArray(opts.province) ? (opts.province.join('|')) : opts.province}`\n    if(opts.days) \n      path += `?lastdays=${opts.days}`\n  }\n  return fetchJson(path)\n}\n\n/**\n * Retrieve a timeline of USA data\n * @returns {object[]} USA timeline data\n */\nnyt.usa = () => fetchJson('v2/nyt/usa')\n\n/**\n * Retrieve a timeline of US state specific data\n * @param {object} opts            object holding the options for that request\n * @param {string} opts.state      state name to be queried \n * @returns {object|object[]} state specific timeline data\n */\nnyt.states = (opts = {}) => {\n  let path = 'v2/nyt/states'\n  if(opts.state) \n    path += `/${opts.state}`\n  return fetchJson(path)\n}\n\n/**\n * Retrieve a timeline of US county specific data\n * @param {object} opts            object holding the options for that request\n * @param {string} opts.county     county name to be queried \n * @returns {object|object[]} county specific timeline data\n */\nnyt.counties = (opts = {}) => {\n  let path = 'v2/nyt/counties'\n  if(opts.county) \n    path += `/${opts.county}`\n  return fetchJson(path)\n}\n\n/**\n * Retrieve an array of available countries\n * @returns {string[]} country names\n */\napple.countries = () => fetchJson('v2/apple/countries')\n\n/**\n * Retrieve a list of available subregions for a country\n * @param {string} country country name to be queried\n * @returns {object}       object containing country name and list of subregions\n */\napple.subregions = (country) => fetchJson(`v2/apple/countries/${country}`)\n\n/**\n * Retrieve mobility data for a specific country and subregion\n * @param {object}               opts           object holding the options for that request\n * @param {string}               opts.country   country name to be queried      \n * @param {string|string[]} opts.subregion subregion name/s to be queried      \n * @returns {object|object[]}              mobility data\n */\napple.mobilityData = (opts = {}) => {\n  let path = 'v2/apple/countries'\n  if(opts.country) {\n    path += `/${opts.country}`\n    if(opts.subregion) \n      path += `/${Array.isArray(opts.subregion) ? (opts.subregion.join('|')) : opts.subregion}`\n  }\n  return fetchJson(path)\n}\n\n/**\n * Retrieve official government data\n * @param {string}  country         country name to be queried (empty to get an array of names)\n * @param {boolean} opts.allowNull  whether to allow null values (true) or automatically transform them to 0 (false)\n * @returns {object}                official government data\n */\nconst gov = (country) => fetchJson(`v2/gov/${country ? country : ''}`)\n\nmodule.exports = {\n  settings,\n  all,\n  countries,\n  continents,\n  states,\n  yesterday,\n  jhucsse,\n  historical,\n  nyt,\n  apple,\n  gov\n}"]},"metadata":{},"sourceType":"script"}