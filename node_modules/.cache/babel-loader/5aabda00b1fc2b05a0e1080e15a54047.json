{"ast":null,"code":"const path = require('path');\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst qs = require('querystring');\n\nconst zlib = require('zlib');\n\nconst {\n  URL\n} = require('url');\n\nconst CentraResponse = require('./CentraResponse');\n\nmodule.exports = class CentraRequest {\n  constructor(url, method = 'GET') {\n    this.url = typeof url === 'string' ? new URL(url) : url;\n    this.method = method;\n    this.data = null;\n    this.sendDataAs = null;\n    this.reqHeaders = {};\n    this.streamEnabled = false;\n    this.compressionEnabled = false;\n    this.coreOptions = {};\n    return this;\n  }\n\n  query(a1, a2) {\n    if (typeof a1 === 'object') {\n      Object.keys(a1).forEach(queryKey => {\n        this.url.searchParams.append(queryKey, a1[queryKey]);\n      });\n    } else {\n      this.url.searchParams.append(a1, a2);\n    }\n\n    return this;\n  }\n\n  path(relativePath) {\n    this.url.pathname = path.join(this.url.pathname, relativePath);\n    return this;\n  }\n\n  body(data, sendAs) {\n    this.sendDataAs = typeof data === 'object' && !sendAs && !Buffer.isBuffer(data) ? 'json' : sendAs ? sendAs.toLowerCase() : 'buffer';\n    this.data = this.sendDataAs === 'form' ? qs.stringify(data) : this.sendDataAs === 'json' ? JSON.stringify(data) : data;\n    return this;\n  }\n\n  header(a1, a2) {\n    if (typeof a1 === 'object') {\n      Object.keys(a1).forEach(headerName => {\n        this.reqHeaders[headerName.toLowerCase()] = a1[headerName];\n      });\n    } else {\n      this.reqHeaders[a1.toLowerCase()] = a2;\n    }\n\n    return this;\n  }\n\n  method(method) {\n    this.method = method;\n    return this;\n  }\n\n  async json() {\n    const res = await this.send();\n    return res.json;\n  }\n\n  async raw() {\n    const res = await this.send();\n    return res.body;\n  }\n\n  async text() {\n    const res = await this.send();\n    return res.text;\n  }\n\n  send() {\n    return new Promise((resolve, reject) => {\n      if (this.data) {\n        if (!this.reqHeaders.hasOwnProperty('content-type')) {\n          if (this.sendDataAs === 'json') this.reqHeaders['content-type'] = 'application/json';else if (this.sendDataAs === 'form') this.reqHeaders['content-type'] = 'application/x-www-form-urlencoded';\n        }\n\n        if (!this.reqHeaders.hasOwnProperty('content-length')) this.reqHeaders['content-length'] = Buffer.byteLength(this.data);\n      }\n\n      const options = {\n        protocol: this.url.protocol,\n        host: this.url.hostname,\n        port: this.url.port,\n        path: this.url.pathname + this.url.search,\n        method: this.method,\n        headers: this.reqHeaders,\n        ...this.coreOptions\n      };\n      let req;\n\n      const resHandler = res => {\n        let stream = res;\n\n        if (this.compressionEnabled) {\n          if (res.headers['content-encoding'] === 'gzip') stream = res.pipe(zlib.createGunzip());else if (res.headers['content-encoding'] === 'deflate') stream = res.pipe(zlib.createInflate());\n        }\n\n        let centraRes;\n\n        if (this.streamEnabled) {\n          resolve(stream);\n        } else {\n          centraRes = new CentraResponse(res);\n          stream.on('error', err => {\n            reject(err);\n          });\n          stream.on('data', chunk => {\n            centraRes._addChunk(chunk);\n          });\n          stream.on('end', () => {\n            resolve(centraRes);\n          });\n        }\n      };\n\n      if (this.url.protocol === 'http:') req = http.request(options, resHandler);else if (this.url.protocol === 'https:') req = https.request(options, resHandler);else throw new Error(`Bad URL protocol: ${this.url.protocol}`);\n      req.on('error', err => {\n        reject(err);\n      });\n      if (this.data) req.write(this.data);\n      req.end();\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/utilizador/Documents/academia/LocalRepo/covid-react-app/node_modules/@aero/centra/lib/CentraRequest.js"],"names":["path","require","http","https","qs","zlib","URL","CentraResponse","module","exports","CentraRequest","constructor","url","method","data","sendDataAs","reqHeaders","streamEnabled","compressionEnabled","coreOptions","query","a1","a2","Object","keys","forEach","queryKey","searchParams","append","relativePath","pathname","join","body","sendAs","Buffer","isBuffer","toLowerCase","stringify","JSON","header","headerName","json","res","send","raw","text","Promise","resolve","reject","hasOwnProperty","byteLength","options","protocol","host","hostname","port","search","headers","req","resHandler","stream","pipe","createGunzip","createInflate","centraRes","on","err","chunk","_addChunk","request","Error","write","end"],"mappings":"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","sourcesContent":["const path = require('path');\nconst http = require('http');\nconst https = require('https');\nconst qs = require('querystring');\nconst zlib = require('zlib');\nconst { URL } = require('url');\n\nconst CentraResponse = require('./CentraResponse');\n\nmodule.exports = class CentraRequest {\n\n\tconstructor(url, method = 'GET') {\n\t\tthis.url = typeof url === 'string' ? new URL(url) : url;\n\t\tthis.method = method;\n\t\tthis.data = null;\n\t\tthis.sendDataAs = null;\n\t\tthis.reqHeaders = {};\n\t\tthis.streamEnabled = false;\n\t\tthis.compressionEnabled = false;\n\t\tthis.coreOptions = {};\n\n\t\treturn this;\n\t}\n\n\tquery(a1, a2) {\n\t\tif (typeof a1 === 'object') {\n\t\t\tObject.keys(a1).forEach(queryKey => {\n\t\t\t\tthis.url.searchParams.append(queryKey, a1[queryKey]);\n\t\t\t});\n\t\t} else {\n\t\t\tthis.url.searchParams.append(a1, a2);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tpath(relativePath) {\n\t\tthis.url.pathname = path.join(this.url.pathname, relativePath);\n\n\t\treturn this;\n\t}\n\n\tbody(data, sendAs) {\n\t\tthis.sendDataAs = typeof data === 'object' && !sendAs && !Buffer.isBuffer(data) ? 'json' : sendAs ? sendAs.toLowerCase() : 'buffer';\n\t\tthis.data = this.sendDataAs === 'form' ? qs.stringify(data) : this.sendDataAs === 'json' ? JSON.stringify(data) : data;\n\n\t\treturn this;\n\t}\n\n\theader(a1, a2) {\n\t\tif (typeof a1 === 'object') {\n\t\t\tObject.keys(a1).forEach(headerName => {\n\t\t\t\tthis.reqHeaders[headerName.toLowerCase()] = a1[headerName];\n\t\t\t});\n\t\t} else {\n\t\t\tthis.reqHeaders[a1.toLowerCase()] = a2;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tmethod(method) {\n\t\tthis.method = method;\n\n\t\treturn this;\n\t}\n\n\tasync json() {\n\t\tconst res = await this.send();\n\t\treturn res.json;\n\t}\n\n\tasync raw() {\n\t\tconst res = await this.send();\n\t\treturn res.body;\n\t}\n\n\tasync text() {\n\t\tconst res = await this.send();\n\t\treturn res.text;\n\t}\n\n\tsend() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (this.data) {\n\t\t\t\tif (!this.reqHeaders.hasOwnProperty('content-type')) {\n\t\t\t\t\tif (this.sendDataAs === 'json') this.reqHeaders['content-type'] = 'application/json';\n\n\t\t\t\t\telse if (this.sendDataAs === 'form') this.reqHeaders['content-type'] = 'application/x-www-form-urlencoded';\n\t\t\t\t}\n\n\t\t\t\tif (!this.reqHeaders.hasOwnProperty('content-length')) this.reqHeaders['content-length'] = Buffer.byteLength(this.data);\n\t\t\t}\n\n\t\t\tconst options = {\n\t\t\t\tprotocol: this.url.protocol,\n\t\t\t\thost: this.url.hostname,\n\t\t\t\tport: this.url.port,\n\t\t\t\tpath: this.url.pathname + this.url.search,\n\t\t\t\tmethod: this.method,\n\t\t\t\theaders: this.reqHeaders,\n\t\t\t\t...this.coreOptions\n\t\t\t};\n\n\t\t\tlet req;\n\n\t\t\tconst resHandler = res => {\n\t\t\t\tlet stream = res;\n\n\t\t\t\tif (this.compressionEnabled) {\n\t\t\t\t\tif (res.headers['content-encoding'] === 'gzip') stream = res.pipe(zlib.createGunzip());\n\n\t\t\t\t\telse if (res.headers['content-encoding'] === 'deflate') stream = res.pipe(zlib.createInflate());\n\t\t\t\t}\n\n\t\t\t\tlet centraRes;\n\n\t\t\t\tif (this.streamEnabled) {\n\t\t\t\t\tresolve(stream);\n\t\t\t\t} else {\n\t\t\t\t\tcentraRes = new CentraResponse(res);\n\n\t\t\t\t\tstream.on('error', err => {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t});\n\n\t\t\t\t\tstream.on('data', chunk => {\n\t\t\t\t\t\tcentraRes._addChunk(chunk);\n\t\t\t\t\t});\n\n\t\t\t\t\tstream.on('end', () => {\n\t\t\t\t\t\tresolve(centraRes);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (this.url.protocol === 'http:') req = http.request(options, resHandler);\n\n\t\t\telse if (this.url.protocol === 'https:') req = https.request(options, resHandler);\n\n\t\t\telse throw new Error(`Bad URL protocol: ${this.url.protocol}`);\n\n\t\t\treq.on('error', err => {\n\t\t\t\treject(err);\n\t\t\t});\n\n\t\t\tif (this.data) req.write(this.data);\n\n\t\t\treq.end();\n\t\t});\n\t}\n\n};\n"]},"metadata":{},"sourceType":"script"}